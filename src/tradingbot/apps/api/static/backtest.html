<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <link rel="icon" href="/static/favicon.ico">
  <title>DMI - TradingBot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="stylesheet" href="/static/styles.css"/>
  <style>
  @keyframes blink{0%,100%{opacity:.2;}50%{opacity:1;}}
  #bt-working{animation:blink 1s linear infinite;display:none;margin-left:8px;}
  </style>
</head>
<body>
<header class="center" style="margin-bottom:8px">
  <div class="logo-wrap">
  <img src="/static/logo.png" alt="DMI Bot Trading" class="logo">
</div>

  <nav>
  <div class="menu">
    <a href="/" class="">Monitoreo</a>
    <a href="/bots" class="">Bots</a>
    <a href="/stats" class="">Estadísticas operativas</a>
    <a href="/data" class="">Datos históricos</a>
    <a href="/backtest" class="active">Backtest</a>
    <a href="http://localhost:3000/" target="_blank" class="">Grafana</a>
    <a href="http://localhost:9090/" target="_blank" class="">Prometheus</a>

  </div>
</nav>

</header>
  <h1>Backtest</h1>

  <div class="card">
    <h2>Ejecutar backtest</h2>
    <div class="grid3" style="margin-top:10px">
      <div>
        <label for="bt-mode">Modo</label>
        <select id="bt-mode">
          <option value="csv">CSV</option>
          <option value="cfg">Config YAML</option>
          <option value="walk">Walk-forward</option>
          <option value="db">Base de datos</option>
        </select>
      </div>
      <div id="field-data">
        <label for="bt-data">Archivo CSV</label>
        <input id="bt-data" placeholder="data.csv"/>
      </div>
      <div id="field-symbol">
        <label for="bt-symbol">Símbolo</label>
        <input id="bt-symbol" placeholder="BTC/USDT"/>
      </div>
      <div id="field-strategy">
        <label for="bt-strategy">Estrategia</label>
        <select id="bt-strategy"></select>
      </div>
      <div id="field-capital">
        <label for="bt-capital">Capital inicial</label>
        <input id="bt-capital" type="number" step="any" placeholder=""/>
      </div>
      <div id="field-config">
        <label for="bt-config">Archivo config</label>
        <input id="bt-config" placeholder="config.yaml"/>
      </div>
      <div id="field-venue">
        <label for="bt-venue">Exchange</label>
        <select id="bt-venue"></select>
      </div>
      <div id="field-start">
        <label for="bt-start">Inicio</label>
        <input id="bt-start" type="date"/>
      </div>
      <div id="field-end">
        <label for="bt-end">Fin</label>
        <input id="bt-end" type="date"/>
      </div>
      <div id="field-risk-pct">
        <label for="bt-risk-pct">Risk %</label>
        <input id="bt-risk-pct" type="number" step="any"/>
      </div>
    </div>
    <p id="bt-strategy-info" class="dm-kind-desc" style="grid-column:1 / -1;"></p>
    <button id="bt-run" style="margin-top:10px">Ejecutar</button>
    <button id="bt-stop" style="margin-top:10px;margin-left:8px" disabled>Detener</button>
    <button id="bt-clear" style="margin-top:10px;margin-left:8px">Limpiar</button>
    <span id="bt-working">Procesando<span id="bt-dots"></span></span>
    <pre id="bt-output" class="mono" style="margin-top:8px; white-space:pre-wrap"></pre>
  </div>

  <div class="card" style="margin-top:16px">
    <h2>Comandos CLI</h2>
    <div class="muted">Ejecuta cualquier comando de <code>tradingbot.cli</code></div>
    <input id="cli-input" class="mono" placeholder="--help"/>
    <button id="cli-run" style="margin-top:8px">Ejecutar</button>
    <pre id="cli-output" class="mono" style="margin-top:8px; white-space:pre-wrap"></pre>
  </div>

<script>
const api = (path) => `${location.origin}${path}`;

function normalizeSymbol(sym) {
  return sym.replace(/[^A-Za-z0-9]/g, "");
}

function appendOutput(out,text){
  out.textContent+=text+"\n";
  requestAnimationFrame(()=>out.scrollTop=out.scrollHeight);
}

function showWorking(){
  const span=document.getElementById('bt-working');
  if(span) span.style.display='inline';
}

function hideWorking(){
  const span=document.getElementById('bt-working');
  if(span) span.style.display='none';
}

let currentJob=null;
let evt=null;
let endTimer=null;
const END_FALLBACK_MS=60000;

function startEndFallback(){
  if(endTimer){clearTimeout(endTimer);}
  endTimer=setTimeout(()=>{
    endTimer=null;
    const runBtn=document.getElementById('bt-run');
    const stopBtn=document.getElementById('bt-stop');
    const out=document.getElementById('bt-output');
    appendOutput(out,'[timeout]');
    appendSummary(out.textContent);
    if(evt){evt.close();}
    currentJob=null;
    stopBtn.disabled=true;
    runBtn.disabled=false;
    runBtn.textContent='Ejecutar';
    hideWorking();
  },END_FALLBACK_MS);
}

const strategies = {
  breakout_atr: {
    desc: "Aprovecha rupturas de un canal calculado con el Average True Range (ATR). Compra al superar la banda superior y vende al romper la inferior.",
    requires: ["ohlcv"],
  },
  breakout_vol: {
    desc: "Busca expansiones de volatilidad. Entra cuando el precio abandona su rango normal con un aumento notable del rango de la vela.",
    requires: ["ohlcv"],
  },
  momentum: {
    desc: "Sigue la tendencia usando el RSI como medidor de impulso. Opera a favor del movimiento cuando el indicador se mantiene en zonas extremas.",
    requires: ["ohlcv"],
  },
  mean_reversion: {
    desc: "Opera la vuelta a la media apoyándose en el RSI. Compra en condiciones de sobreventa y vende en sobrecompra.",
    requires: ["ohlcv"],
  },
  triangular_arb: {
    desc: "Explota ineficiencias entre tres pares realizando un ciclo de intercambios para obtener beneficio sin exposición direccional.",
    requires: ["prices"],
  },
  cash_and_carry: {
    desc: "Captura la base entre mercado spot y futuros perpetuos, manteniendo posiciones opuestas y cobrando la tasa de financiamiento.",
    requires: ["spot", "perp", "funding"],
  },
  order_flow_imbalance: {
    desc: "Evalúa el desequilibrio entre órdenes de compra y venta agresivas para anticipar movimientos de precio.",
    requires: ["bba", "book_delta"],
  },
  depth_imbalance: {
    desc: "Mide la disparidad de liquidez entre el lado comprador y vendedor del libro para detectar presión latente.",
    requires: ["book_delta"],
  },
  liquidity_events: {
    desc: "Identifica vacíos y gaps de liquidez en el libro que pueden generar movimientos bruscos.",
    requires: ["bba", "book_delta"],
  },
  triple_barrier: {
    desc: "Genera señales usando la metodología de triple barrera con objetivos y stop temporales.",
    requires: ["ohlcv"],
  },
  ml: {
    desc: "Ejecuta un modelo de machine learning entrenado con indicadores y estadísticas personalizadas.",
    requires: ["features"],
  },
  mean_rev_ofi: {
    desc: "Busca la reversión a la media basada en el Order Flow Imbalance (OFI) derivado del libro de órdenes.",
    requires: ["book_delta"],
  },
  order_flow: {
    desc: "Analiza el flujo de órdenes agresivas vs. pasivas para estimar micro‑tendencias.",
    requires: ["trades", "book_delta"],
  },
  cross_arbitrage: {
    desc: "Arbitraje del mismo par entre dos exchanges; compra donde esté barato y vende donde esté caro.",
    requires: ["prices"],
  },
};

const dataInfo = {
  ohlcv: "Serie de velas con Open-High-Low-Close-Volume.",
  prices: "Secuencia de precios (spot o perp) en ticks/velas, útil para spreads.",
  bba: "Best Bid/Ask (mejor postor y oferente) con sus volúmenes.",
  book_delta: "Variaciones por nivel del libro entre dos snapshots consecutivos.",
  trades: "Historial de operaciones ejecutadas (agresivas).",
  spot: "Precio de mercado spot.",
  perp: "Precio de futuros perpetuos.",
  funding: "Historial de tasas de financiamiento de los perpetuos.",
  features: "Indicadores y estadísticas usados por un modelo de ML.",
};

let strategyInfo = strategies;

function appendSummary(text){
  try{
    let eq=null,pnl=null,fills=null,dd=null,slip=null;
    const re=/Backtest finalizado: equity (\S+), pnl (\S+), fills (\d+), drawdown (\S+)%/;
    const m=text.match(re);
    if(m){
      eq=parseFloat(m[1]);
      pnl=parseFloat(m[2]);
      fills=parseInt(m[3],10);
      dd=parseFloat(m[4]);
    }else{
      const eqMatch=text.match(/'equity':\s*(\S+)/);
      const pnlMatch=text.match(/'pnl':\s*(\S+)/);
      const ddMatch=text.match(/'max_drawdown':\s*(\S+)/);
      const fillsMatch=text.match(/'fills':\s*\[(.*)\]/s);
      const slipMatch=text.match(/'slippage':\s*(\S+)/);
      eq=eqMatch?parseFloat(eqMatch[1]):null;
      pnl=pnlMatch?parseFloat(pnlMatch[1]):null;
      dd=ddMatch?parseFloat(ddMatch[1])*100:null;
      slip=slipMatch?parseFloat(slipMatch[1]):null;
      if(fillsMatch){
        fills=(fillsMatch[1].match(/\(/g)||[]).length;
      }
    }
    const out=document.getElementById('bt-output');
    const lines=[
      '',
      `equity final ≈ ${eq!=null&&!isNaN(eq)?eq.toFixed(2):(m?m[1]:'N/A')}`,
      `pnl total ≈ ${pnl!=null&&!isNaN(pnl)?pnl.toFixed(2):(m?m[2]:'N/A')}`,
      `${fills!=null?fills:'N/A'} fills (operaciones ejecutadas)`,
      `drawdown máximo ≈ ${dd!=null&&!isNaN(dd)?dd.toFixed(2):(m?m[4]:'N/A')}%`,
    ];
    if(slip!=null&&!isNaN(slip)){
      lines.push(`slippage medio ≈ ${slip.toFixed(2)}`);
    }
    lines.push('');
    lines.forEach(l=>appendOutput(out,l));
  }catch(e){/* ignore parsing errors */}
}

async function loadExchanges(){
  try{
    const r = await fetch(api('/ccxt/exchanges'));
    const exchanges = (await r.json()).filter(
      ex => !ex.endsWith('_testnet') && !ex.endsWith('_ws')
    );
    const sel = document.getElementById('bt-venue');
    sel.innerHTML = '';
    for(const ex of exchanges){
      const opt = document.createElement('option');
      opt.value = ex;
      opt.textContent = ex;
      sel.appendChild(opt);
    }
  }catch(e){
    console.error(e);
  }
}

async function loadStrategies(){
  try{
    const r=await fetch(api('/strategies/status'));
    const j=await r.json();
    const sel=document.getElementById('bt-strategy');
    sel.innerHTML='';
    Object.keys(j.strategies||{}).forEach(s=>{
      const o=document.createElement('option');
      o.value=s;o.textContent=s;sel.appendChild(o);
    });
    updateStrategyInfo();
  }catch(e){console.error(e);}
}

function updateBtFields(){
  const mode=document.getElementById('bt-mode').value;
  document.getElementById('field-data').style.display=mode==='csv'?'':'none';
  document.getElementById('field-symbol').style.display=(mode==='csv'||mode==='db')?'':'none';
  document.getElementById('field-strategy').style.display=(mode==='csv'||mode==='db')?'':'none';
  document.getElementById('field-config').style.display=(mode==='cfg'||mode==='walk')?'':'none';
  document.getElementById('field-venue').style.display=mode==='db'?'':'none';
  document.getElementById('bt-venue').style.display=mode==='db'?'':'none';
  document.getElementById('field-start').style.display=mode==='db'?'':'none';
  document.getElementById('field-end').style.display=mode==='db'?'':'none';
  const showRisk = mode!=='walk';
  ['field-risk-pct'].forEach(id=>{
    document.getElementById(id).style.display=showRisk?'':'none';
  });
}

function updateStrategyInfo(){
  const sel=document.getElementById('bt-strategy');
  const info=strategyInfo[sel.value]||{};
  const el=document.getElementById('bt-strategy-info');
  if(info.desc){
    let html=`<p>${info.desc}</p>`;
    if(info.requires && info.requires.length){
      html += "<p>Datos necesarios:</p><ul>" +
              info.requires.map(r => `<li><strong>${r}</strong>: ${dataInfo[r]}</li>`).join("") +
              "</ul>";
    }
    el.innerHTML = html;
  }else{
    el.textContent='';
  }
}

async function runBacktest(){
  if(evt){evt.close();evt=null;}
  const runBtn=document.getElementById('bt-run');
  runBtn.disabled=true;
  runBtn.textContent='Ejecutando...';
  const stopBtn=document.getElementById('bt-stop');
  const outEl=document.getElementById('bt-output');
  outEl.textContent='Iniciando...\n';
  let cmd='';
  const mode=document.getElementById('bt-mode').value;
  const capital=document.getElementById('bt-capital').value.trim();
  if(mode==='csv'){
    const data=document.getElementById('bt-data').value.trim();
    const sym=normalizeSymbol(document.getElementById('bt-symbol').value.trim());
    const strat=document.getElementById('bt-strategy').value.trim();
    cmd=`backtest ${data} --symbol ${sym} --strategy ${strat}`;
  }else if(mode==='cfg'){
    const cfg=document.getElementById('bt-config').value.trim();
    cmd=`backtest-cfg ${cfg}`;
  }else if(mode==='walk'){
    const cfg=document.getElementById('bt-config').value.trim();
    cmd=`walk-forward ${cfg}`;
  }else{
    const venue=document.getElementById('bt-venue').value.trim();
    const sym=normalizeSymbol(document.getElementById('bt-symbol').value.trim());
    const strat=document.getElementById('bt-strategy').value.trim();
    const start=document.getElementById('bt-start').value;
    const end=document.getElementById('bt-end').value;
    cmd=`backtest-db --venue ${venue} --symbol ${sym} --strategy ${strat} --start ${start} --end ${end}`;
  }
  if(capital && mode!=='walk'){
    cmd+=` --capital ${capital}`;
  }
  if(mode!=='walk'){
    const sl=document.getElementById('bt-risk-pct').value.trim();
    if(sl) cmd+=` --risk-pct ${sl}`;
  }
  try{
    const r=await fetch(api('/cli/start'),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({command:cmd})});
    const j=await r.json();
    currentJob=j.id;
    stopBtn.disabled=false;
    showWorking();
    startEndFallback();
    evt=new EventSource(api(`/cli/stream/${j.id}`));
    evt.onmessage=(e)=>appendOutput(outEl,e.data);
    evt.addEventListener('end',(e)=>{
      if(endTimer){clearTimeout(endTimer);endTimer=null;}
      stopBtn.disabled=true;
      runBtn.disabled=false;
      runBtn.textContent='Ejecutar';
      currentJob=null;
      evt.close();
      hideWorking();
      appendSummary(outEl.textContent);
      appendOutput(outEl,`Proceso finalizado (código ${e.data}).`);
    });
    evt.onerror=()=>{
      if(endTimer){clearTimeout(endTimer);endTimer=null;}
      appendOutput(outEl,'[error de conexión]');
      stopBtn.disabled=true;
      runBtn.disabled=false;
      runBtn.textContent='Ejecutar';
      hideWorking();
    };
  }catch(e){
    if(endTimer){clearTimeout(endTimer);endTimer=null;}
    appendOutput(outEl,String(e));
    runBtn.disabled=false;
    runBtn.textContent='Ejecutar';
    hideWorking();
  }
}

async function stopBacktest(){
  if(!currentJob) return;
  try{await fetch(api(`/cli/stop/${currentJob}`),{method:'POST'});}catch(e){}
  if(evt) evt.close();
  document.getElementById('bt-stop').disabled=true;
  const runBtn=document.getElementById('bt-run');
  runBtn.disabled=false;
  runBtn.textContent='Ejecutar';
  currentJob=null;
  if(endTimer){clearTimeout(endTimer);endTimer=null;}
  hideWorking();
}

async function runCli(){
  const cmd=document.getElementById('cli-input').value;
  if(!cmd.trim()) return;
  try{
    const r=await fetch(api('/cli/run'),{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({command:cmd})});
    const j=await r.json();
    const out=(j.stdout||'')+(j.stderr?`\n${j.stderr}`:'');
    document.getElementById('cli-output').textContent=out;
  }catch(e){
    document.getElementById('cli-output').textContent=String(e);
  }
}

document.getElementById('bt-mode').addEventListener('change',updateBtFields);
document.getElementById('bt-run').addEventListener('click',runBacktest);
document.getElementById('bt-stop').addEventListener('click',stopBacktest);
document.getElementById('bt-clear').addEventListener('click',()=>{
  document.getElementById('bt-output').textContent='';
  if(endTimer){clearTimeout(endTimer);endTimer=null;}
  hideWorking();
});
document.getElementById('cli-run').addEventListener('click',runCli);
document.getElementById('bt-strategy').addEventListener('change',updateStrategyInfo);
updateBtFields();
loadStrategies();
loadExchanges();
</script>
</body>
</html>
