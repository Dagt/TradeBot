"""Utilities for processing fills generated by :class:`PaperAdapter`."""

from __future__ import annotations

from typing import Iterable, Mapping, Any
import json
import logging

from ..risk.service import RiskService


def process_paper_fills(
    fills: Iterable[Mapping[str, Any]] | None,
    risk: RiskService,
    symbol: str,
    *,
    venue: str = "paper",
    logger: logging.Logger | None = None,
) -> None:
    """Feed deferred ``fills`` back into ``risk`` bookkeeping.

    Parameters
    ----------
    fills:
        Sequence of fill dictionaries produced by :meth:`PaperAdapter.update_last_price`.
    risk:
        Risk service that should receive the fills.
    symbol:
        Trading symbol for the fills.
    venue:
        Venue identifier used when reporting the fills to ``risk``.
    logger:
        Optional logger used to emit ``METRICS`` entries mirroring other
        execution paths.
    """

    if not fills:
        return

    for fill in fills:
        qty_raw = fill.get("qty")
        try:
            qty = float(qty_raw)
        except (TypeError, ValueError):  # pragma: no cover - defensive
            continue
        if qty <= 0:
            continue

        side = fill.get("side")
        if not side:
            continue

        price_raw = fill.get("price")
        try:
            price = float(price_raw) if price_raw is not None else None
        except (TypeError, ValueError):  # pragma: no cover - defensive
            price = None

        risk.on_fill(symbol, side, qty, price=price, venue=venue)

        if logger is None:
            continue

        pending_raw = fill.get("pending_qty", 0.0)
        try:
            pending_qty = float(pending_raw)
        except (TypeError, ValueError):  # pragma: no cover - defensive
            pending_qty = 0.0

        locked_cash = float(risk.account.cash - risk.account.get_available_balance())
        meta = {
            "event": "fill",
            "side": side,
            "price": price,
            "qty": qty,
            "pending_qty": pending_qty,
            "fee_type": fill.get("fee_type"),
            "realized_pnl": fill.get("realized_pnl"),
        }
        logger.info("METRICS %s", json.dumps(meta))
        logger.info(
            "METRICS %s",
            json.dumps(
                {
                    "event": "locked_cash",
                    "value": locked_cash,
                    "available_cash": risk.account.get_available_balance(),
                    "total_cash": risk.account.cash,
                }
            ),
        )
